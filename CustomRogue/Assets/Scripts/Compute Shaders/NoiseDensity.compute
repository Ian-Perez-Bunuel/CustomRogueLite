#pragma kernel Density
#include "Includes/Density.hlsl"
#include "Includes/Noise.hlsl"

// Noise settings
StructuredBuffer<float3> offsets;
int octaves;
float lacunarity;
float persistence;
float noiseScale;
float noiseWeight;
float weightMultiplier;
float floorOffset;

float verticalBiasStrength = 1.0f;
float worldMinY;
float middleFill;
float worldMaxY;

float4 params;

[numthreads(numThreads, numThreads, numThreads)]
void Density(int3 id : SV_DispatchThreadID)
{
    if (id.x >= numPointsPerAxis || id.y >= numPointsPerAxis || id.z >= numPointsPerAxis)
    {
        return;
    }

    float3 pos = centre + id * spacing - boundsSize / 2;
    float offsetNoise = 0;

    float noise = 0; // will store the final combined noise value from all octaves.

    float frequency = noiseScale / 100; // starting frequency of the noise (how zoomed in / out).
    float amplitude = 1;
    float weight = 1; // used for a "ridged" / sharper noise effect inside the loop
    for (int j = 0; j < octaves; j++)
    {
        float n = snoise((pos + offsetNoise) * frequency + offsets[j] + offset); // Basic noise (range: -1, 1)
        // Sharpening
        float v = 1 - abs(n);
        v = v * v;
        // Apply updated weight
        v *= weight;
        weight = max(min(v * weightMultiplier, 1), 0);
        // Add to total noise and update frequency / amplitude
        noise += v * amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    
    // 0 at bottom, 1 at top
    float y01 = saturate((pos.y - worldMinY) / (worldMaxY - worldMinY));
    
    // 1 at bottom & top, 0 in the middle
    float edgeBias = abs(y01 - 0.5) * 2.0;
    float verticalBias = lerp(middleFill, 1.0, edgeBias); // range[-1, 1]
    verticalBias *= verticalBiasStrength;
    
    float noiseVal = noise * noiseWeight;
    
    float finalVal = verticalBias - noiseVal;


    int index = indexFromCoord(id.x, id.y, id.z);
    points[index] = float4(pos, finalVal);
    
}
